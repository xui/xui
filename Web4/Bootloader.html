<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />

<style>
    body {
        font-family: sans-serif;
        height: 100vh;
        margin: 0;
        touch-action: pan-x pan-y;
        display: flex; flex-direction: column; justify-content: center;
    }
    column { display: flex; flex-direction: column; justify-content: center; }
    row    { display: flex; flex-direction: row;    justify-content: center; }

    @keyframes slide-in        { from { opacity: 0; translate: 50px; } }
    @keyframes slide-out       { to   { opacity: 0; translate: -50px; } }
    @keyframes zoom-fade-in    { from { opacity: 0; scale: 1.2; } }
    @keyframes zoom-fade-out   { to   { opacity: 0; scale: .8; } }
    ::view-transition-group(*) { animation-duration: 300ms; animation-timing-function: ease-in-out; }
</style>

<script>

  function setTextNode(key, value) {
    let textNode = keyholes[key];
    textNode.nodeValue = value;
  }

  function setAttribute(key, value) {
    let attribute = keyholes[key];
    if (typeof value !== "boolean") {
      attribute.value = value;
    } else {
      let attrName = attribute.booleanAttribute;
      attribute.owner[attrName] = value;
    }
  }

  function replaceElement(key, rawHtml, transition) {
    let oldElement = keyholes[key];
    let newElement = document
      .createRange()
      .createContextualFragment(rawHtml)
      .children[0];
    keyholes[key] = newElement;
    registerKeys(newElement, key);

    // No transition
    let isInTransitionContainer = ["ROW", "COL", "BODY"].includes(oldElement.parentElement.tagName);
    if (!document.startViewTransition || !transition || !isInTransitionContainer) {
      oldElement.replaceWith(newElement);
      return;
    }
    
    // View Transition API
    let direction = !rawHtml.includes("World") ? "fwd" : "rev"; // TODO: FAKE!!!
    let viewTransitionName = `web4-${key}-${direction}`;
    oldElement.style.viewTransitionName = viewTransitionName;
    newElement.style.viewTransitionName = viewTransitionName;
    oldElement.parentElement.childNodes.forEach((sibling, i) => {
      if (sibling != oldElement && sibling.style)
        sibling.style.viewTransitionName = `web4-sibling-${i}`
    });

    document.startViewTransition(() => {
      oldElement.replaceWith(newElement);
    })
    .finished.then(() => {
      newElement.parentElement.childNodes.forEach(sibling => {
        if (sibling.style?.viewTransitionName?.startsWith("web4")) {
          sibling.style.removeProperty("view-transition-name");
          if (sibling.style.length == 0)
            sibling.removeAttribute("style");
        }
      });
    });
  }

  function moveElement() {

  }

  function addElement() {

  }

  function removeElement() {

  }

  function clientRpc(event) {
    let batch = JSON.parse(event.data);
    batch = Array.isArray(batch) ? batch : [batch];
    batch.forEach(rpc => {
      let func = rpc.method
        .split(".")
        .reduce((obj, prop) => obj[prop], window);
      func(...rpc.params);
    });
  }

  function serverRpc(key, event, includeProperties) {
    if (event && !event.propagationID)
      event.propagationID = ++propagationID;

    if (includeProperties?.includes("preventDefault")) {
      event?.preventDefault();
      if (includeProperties === "preventDefault")
        includeProperties = null;
    }
    includeProperties = includeProperties?.split(",") ?? ALLOWED_EVENT_PROPERTIES;

    let message = JSON.stringify(
      { jsonrpc: "2.0", method: key, params: event }, 
      [ "jsonrpc", "method", "params", ...includeProperties, "propagationID" ]
    );
    ws.send(message);
  }

  function registerKeys(parentNode, parentKey) {
    let comments = document.evaluate('//comment()', parentNode, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
    for (let i = comments.snapshotLength - 1; i >= 0; i--) {
      let comment = comments.snapshotItem(i);
      let key = comment.textContent;
      if (key.startsWith('key')) {
        let keyhole = comment.previousSibling;
        if (keyhole.nodeType === Node.COMMENT_NODE) {
          // Text node was missing because keyhole value was ""
          // e.g. `<!----><!--key123-->`
          keyhole = keyhole.parentNode.insertBefore(document.createTextNode(""), comment);
        } else if (keyhole.nodeType == Node.ELEMENT_NODE) {
          // keyhole.style.viewTransitionName = key;
        }

        keyholes[key] = keyhole;
      }
      comment.parentElement.removeChild(comment);
    }
    if (parentKey) {
      // parentNode.style.viewTransitionName = parentKey;
    }
    
    let attrs = document.evaluate('//*/attribute::*', parentNode, null, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
    for (let i = 0; i < attrs.snapshotLength; i++) {
      let attr = attrs.snapshotItem(i);
      let key = attr.name;
      if (key.startsWith('key')) {
        if (attr.value === "") {
          keyholes[key] = attrs.snapshotItem(i - 1);
        } else {
          keyholes[key] = { 
            nodeType: Node.ENTITY_REFERENCE_NODE, 
            booleanAttribute: attr.value, 
            owner: attr.ownerElement
          };
        }
        attr.ownerElement.removeAttribute(attr.name)
      }
    }
  }

  function openServerConsole() {
    new EventSource(`${location.pathname}/web4/console`)
      .onmessage = clientRpc;
  }

  async function updateConnectionState(e) {
    switch (ws?.readyState) {
      case WebSocket.CONNECTING:
        showModal();
        break;
      case WebSocket.OPEN:
        document.getElementById("web4Modal")?.close();
        break;
      case WebSocket.CLOSING:
      case WebSocket.CLOSED:
        showModal();
        document.getElementById("web4ModalMessage").textContent = e.reason ? e.reason : "Looking for server...";
        if (reconnectionAttempts == 0) {
          while (++reconnectionAttempts <= 10) {
            console.debug(`Web4 reconnect: (attempt ${reconnectionAttempts} of 10)...`);
            new WebSocket(`${location.pathname}/web4/alive`)
              .onopen = e => location.reload();
            await new Promise(resolve => setTimeout(resolve, 1000));
          }
          reconnectionAttempts = 0;
        }
        break;
    }
  }

  function showModal() {
    let web4Modal = document.getElementById("web4Modal");
    if (!web4Modal) {
      document.body.appendChild(web4ModalTemplate.content.cloneNode(true));
      web4Modal = document.getElementById("web4Modal");
    }
    web4Modal.showModal();
  }

  let ws;
  let keyholes = {};
  let propagationID = 0;
  let reconnectionAttempts = 0;
  const ALLOWED_EVENT_PROPERTIES = [ "absolute", "acceleration", "accelerationIncludingGravity", "alpha", "altitudeAngle", "altKey", "animationName", "azimuthAngle", "beta", "bubbles", "button", "buttons", "cancelable", "changedTouches", "clientX", "clientY", "code", "colNo", "composed", "ctrlKey", "currentTarget", "data", "dataTransfer", "defaultPrevented", "deltaMode", "deltaX", "deltaY", "deltaZ", "detail", "elapsedTime", "error", "eventPhase", "fileName", "gamma", "height", "inputType", "interval", "isComposing", "isPrimary", "isTrusted", "key", "length", "lengthComputable", "lineNo", "loaded", "location", "message", "metaKey", "movementX", "movementY", "newState", "newUrl", "offsetX", "offsetY", "oldState", "oldUrl", "pageX", "pageY", "persisted", "pointerID", "pointerType", "pressure", "propertyName", "pseudoElement", "relatedTarget", "repeat", "rotationRate", "screenX", "screenY", "shiftKey", "skipped", "submitter", "tangentialPressure", "target", "targetTouches", "timeStamp", "tiltX", "tiltY", "total", "touches", "twist", "type", "width", "x", "y", "id", "name", "value", "checked" ];

  document.addEventListener('DOMContentLoaded', () => {
    registerKeys(document);
    ws = new WebSocket(`${location.pathname}/web4`);
    ws.onmessage = clientRpc;
    ws.onerror = console.error;
    ws.onopen = updateConnectionState;
    ws.onclose = updateConnectionState;
    setTimeout(updateConnectionState, 1000);
    window.onbeforeunload = e => ws = undefined;
    window.addEventListener("online", updateConnectionState);
    window.addEventListener("visibilitychange", updateConnectionState);
  });

</script>

<template id="web4ModalTemplate">
  <dialog id="web4Modal" onkeydown="event.preventDefault()" onmouseenter="updateConnectionState(event)">
      <div>
          <progress></progress>
          <div id="web4ModalMessage">Looking for server...</div>
      </div>
  </dialog>
  <style>
    #web4Modal::backdrop { background-color: #ffffff66; backdrop-filter: grayscale(0.75) blur(6px); }
    #web4Modal:focus { outline: none; }
    #web4Modal[open] { 
        background-color: transparent; 
        border-width: 0;
        animation: .5s cubic-bezier(0.165, 0.840, 0.440, 1.000) forwards zoom-fade-in;
    }
  </style>
</template>