
<!-- <link rel="manifest" href="/app/manifest.json" /> -->
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />

<style>
    body {
        font-family: sans-serif;
        height: 100vh;
        margin: 0;
        touch-action: pan-x pan-y;
        display: flex; flex-direction: column; justify-content: center;
    }
    column { display: flex; flex-direction: column; justify-content: center; }
    row    { display: flex; flex-direction: row;    justify-content: center; }
    list   { display: flex; flex-direction: column; justify-content: center; }
    lr     { display: flex; flex-direction: row;    justify-content: center; }
    ld     { display: flex; flex-direction: column; justify-content: center; }
    svg    { margin: 8px; }

    @keyframes slide-in        { from { opacity: 0; translate: 50px; } }
    @keyframes slide-out       { to   { opacity: 0; translate: -50px; } }
    @keyframes zoom-fade-in    { from { opacity: 0; scale: 1.2; } }
    @keyframes zoom-fade-out   { to   { opacity: 0; scale: .8; } }
    ::view-transition-group(*) { animation-duration: 300ms; animation-timing-function: ease-in-out; }
</style>

<script>

  class Web4App {
    keyholes = new Web4Keyholes();

    constructor() {
      document.addEventListener('DOMContentLoaded', () => this.#connect());
    }

    ping = function(repeat) {
      repeat = repeat ?? 1;
      for (let i = 0; i < repeat; i++) {
        console.time("ping");
        console.timeEnd("ping");
      }
    }

    pong = function(id) {
      
    }

    #callAll(event) {
      let batch = JSON.parse(event.data);
      batch = Array.isArray(batch) ? batch : [batch];
      batch.forEach(rpc => {
        let [obj, func] = rpc.method
          .split(".")
          .reduce(([obj, func], prop) => [func, func[prop]], [null, window]);
        func.apply(obj, rpc.params);
      });
    }

    #connect() {
      let webSocket = new WebSocket(`${location.pathname}/web4`);
      webSocket.onmessage = this.#callAll;
      webSocket.onerror = console.error;
      webSocket.onopen = e => updateConnectionState(webSocket, e);
      webSocket.onclose = e => updateConnectionState(webSocket, e);
      setTimeout(e => updateConnectionState(webSocket, e), 1000);
      window.addEventListener("online", e => updateConnectionState(webSocket, e));
      window.addEventListener("visibilitychange", e => updateConnectionState(webSocket, e));
      window.onbeforeunload = e => webSocket = undefined;

      let propagationID = 0;
      const ALLOWED_EVENT_PROPERTIES = [ "absolute", "acceleration", "accelerationIncludingGravity", "alpha", "altitudeAngle", "altKey", "animationName", "azimuthAngle", "beta", "bubbles", "button", "buttons", "cancelable", "changedTouches", "clientX", "clientY", "code", "colNo", "composed", "ctrlKey", "currentTarget", "data", "dataTransfer", "defaultPrevented", "deltaMode", "deltaX", "deltaY", "deltaZ", "detail", "elapsedTime", "error", "eventPhase", "fileName", "gamma", "height", "inputType", "interval", "isComposing", "isPrimary", "isTrusted", "key", "length", "lengthComputable", "lineNo", "loaded", "location", "message", "metaKey", "movementX", "movementY", "newState", "newUrl", "offsetX", "offsetY", "oldState", "oldUrl", "pageX", "pageY", "persisted", "pointerID", "pointerType", "pressure", "propertyName", "pseudoElement", "relatedTarget", "repeat", "rotationRate", "screenX", "screenY", "shiftKey", "skipped", "submitter", "tangentialPressure", "target", "targetTouches", "timeStamp", "tiltX", "tiltY", "total", "touches", "twist", "type", "width", "x", "y", "id", "name", "value", "checked" ];
      this.dispatchEvent = function(key, event, includeProperties) {
        if (event && !event.propagationID)
          event.propagationID = ++propagationID;

        if (includeProperties?.includes("preventDefault")) {
          event?.preventDefault();
          if (includeProperties === "preventDefault")
            includeProperties = null;
        }
        includeProperties = includeProperties?.split(",") ?? ALLOWED_EVENT_PROPERTIES;

        let message = JSON.stringify(
          { jsonrpc: "2.0", method: key, params: event }, 
          [ "jsonrpc", "method", "params", ...includeProperties, "propagationID" ]
        );
        webSocket.send(message);
      }

      let reconnectionAttempts = 0;
      async function updateConnectionState(e) {
        switch (webSocket?.readyState) {
          case WebSocket.CONNECTING:
            getOrCreateModal().showModal();
            break;
          case WebSocket.OPEN:
            document.getElementById("web4Modal")?.close();
            break;
          case WebSocket.CLOSING:
          case WebSocket.CLOSED:
            getOrCreateModal().showModal();
            document.getElementById("web4ModalMessage").textContent = e.reason ? e.reason : "Looking for server...";
            if (reconnectionAttempts == 0) {
              while (++reconnectionAttempts <= 10) {
                console.debug(`Web4 reconnect: (attempt ${reconnectionAttempts} of 10)...`);
                new WebSocket(`${location.pathname}/web4/alive`)
                  .onopen = e => location.reload();
                await new Promise(resolve => setTimeout(resolve, 1000));
              }
              reconnectionAttempts = 0;
            }
            break;
        }
      }

      function getOrCreateModal() {
        let web4Modal = document.getElementById("web4Modal");
        if (!web4Modal) {
          document.body.appendChild(web4ModalTemplate.content.cloneNode(true));
          web4Modal = document.getElementById("web4Modal")
        }
        return web4Modal;
      }
    }

    // Proxied from window.document
    setTitle = title => document.title = title;
  }

  class Web4Keyholes {
    all = {};

    constructor() {
      // Object.defineProperty(this, 'all', { get() { return this.#all; } });
      document.addEventListener('DOMContentLoaded', () => this.#registerKeyholes(document));
    }

    toConsole = function() {
      console.log("Keyholes (144)");
    }

    setTextNode = function(key, value) {
      let textNode = this.all[key];
      textNode.nodeValue = value;
    }

    setAttribute = function(key, value) {
      let attribute = this.all[key];
      if (typeof value !== "boolean") {
        attribute.value = value;
      } else {
        let attrName = attribute.booleanAttribute;
        attribute.owner[attrName] = value;
      }
    }

    setElement = function(key, rawHtml, transition) {
      let oldElement = this.all[key];
      let newElement = document
        .createRange()
        .createContextualFragment(rawHtml)
        .children[0];
      this.all[key] = newElement;
      this.#registerKeyholes(newElement);

      // No transition
      let isInTransitionContainer = ["ROW", "COL", "LIST", "BODY"].includes(oldElement.parentElement.tagName);
      if (!document.startViewTransition || !transition || !isInTransitionContainer) {
        oldElement.replaceWith(newElement);
        return;
      }
      
      // View Transition API
      let direction = !rawHtml.includes("World") ? "fwd" : "rev"; // TODO: FAKE!!!
      oldElement.parentElement.childNodes.forEach((sibling, i) => {
        if (sibling.style)
          sibling.style.viewTransitionName = `web4-sibling-${i}`
      });
      oldElement.style.viewTransitionName = `web4-${key}-${direction}`;
      newElement.style.viewTransitionName = `web4-${key}-${direction}`;

      document.startViewTransition(() => {
        oldElement.replaceWith(newElement);
      })
      .finished.then(() => {
        newElement.parentElement.childNodes.forEach(sibling => {
          if (sibling.style?.viewTransitionName?.startsWith("web4")) {
            sibling.style.removeProperty("view-transition-name");
            if (sibling.style.length == 0)
              sibling.removeAttribute("style");
          }
        });

        this.#unregisterKeyholes();
      });
    }

    addElement = function() {
    }

    removeElement = function(key, transition) {
      let element = this.all[key];

      // No transition
      let isInTransitionContainer = ["ROW", "COL", "LIST", "BODY"].includes(element.parentElement.tagName);
      if (!document.startViewTransition || !transition || !isInTransitionContainer) {
        element.parentNode.removeChild(element);
        return;
      }

      // View Transition API
      let parentElement = element.parentElement;
      parentElement.childNodes.forEach((sibling, i) => {
        if (sibling.style)
          sibling.style.viewTransitionName = `web4-sibling-${i}`
      });
      element.style.viewTransitionName = `web4-${key}`;

      document.startViewTransition(() => {
        element.parentNode.removeChild(element);
      })
      .finished.then(() => {
        parentElement.childNodes.forEach(sibling => {
          if (sibling.style?.viewTransitionName?.startsWith("web4")) {
            sibling.style.removeProperty("view-transition-name");
            if (sibling.style.length == 0)
              sibling.removeAttribute("style");
          }
        });

        this.#unregisterKeyholes();
      });
    }

    #registerKeyholes(parentNode) {
      let comments = document.evaluate('//comment()', parentNode, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
      for (let i = comments.snapshotLength - 1; i >= 0; i--) {
        let comment = comments.snapshotItem(i);
        let key = comment.textContent;
        if (key.startsWith('key')) {
          let keyhole = comment.previousSibling;
          if (keyhole.nodeType === Node.COMMENT_NODE) {
            // Text node was missing because keyhole value was "", e.g. `<!----><!--key123-->`
            keyhole = keyhole.parentNode.insertBefore(document.createTextNode(""), comment);
          }
          app.keyholes.all[key] = keyhole;
        }
        comment.parentElement.removeChild(comment);
      }
      
      let attrs = document.evaluate('//*/attribute::*', parentNode, null, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
      for (let i = 0; i < attrs.snapshotLength; i++) {
        let attr = attrs.snapshotItem(i);
        let key = attr.name;
        if (key.startsWith('key')) {
          if (attr.value === "") {
            app.keyholes.all[key] = attrs.snapshotItem(i - 1);
          } else {
            app.keyholes.all[key] = { 
              nodeType: Node.ENTITY_REFERENCE_NODE, 
              booleanAttribute: attr.value, 
              owner: attr.ownerElement
            };
          }
          attr.ownerElement.removeAttribute(attr.name)
        }
      }

      this.#unregisterKeyholes();
    }

    static #unregisterKeyholes() {
      for (let key in app.keyholes.all) {
        if (!document.body.contains(app.keyholes.all[key]))
          delete app.keyholes.all[key];
      }
    }
  }

  this.app = new Web4App();

</script>

<template id="web4ModalTemplate">
  <dialog id="web4Modal" onkeydown="event.preventDefault()">
    <div>
      <progress></progress>
      <div id="web4ModalMessage">Looking for server...</div>
    </div>
  </dialog>
  <style>
    #web4Modal::backdrop { background-color: #ffffff66; backdrop-filter: grayscale(0.75) blur(6px); }
    #web4Modal:focus { outline: none; }
    #web4Modal[open] { 
        background-color: transparent; 
        border-width: 0;
        animation: .5s cubic-bezier(0.165, 0.840, 0.440, 1.000) forwards zoom-fade-in;
    }
  </style>
</template>
