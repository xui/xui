
<!-- <link rel="manifest" href="/app/manifest.json" /> -->
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<meta charset="UTF-8">

<style>
    body {
        font-family: sans-serif;
        height: 100vh;
        margin: 0;
        touch-action: pan-x pan-y;
        display: flex; flex-direction: column; justify-content: center;
    }
    column { display: flex; flex-direction: column; justify-content: center; }
    row    { display: flex; flex-direction: row;    justify-content: center; }
    list   { display: flex; flex-direction: column; justify-content: center; }
    lr     { display: flex; flex-direction: row;    justify-content: center; }
    ld     { display: flex; flex-direction: column; justify-content: center; }
    svg    { margin: 8px; }
    button { height: 44px; }

    @keyframes slide-in        { from { opacity: 0; translate: 50px; } }
    @keyframes slide-out       { to   { opacity: 0; translate: -50px; } }
    @keyframes zoom-fade-in    { from { opacity: 0; scale: 1.2; } }
    @keyframes zoom-fade-out   { to   { opacity: 0; scale: .8; } }
    ::view-transition-group(*) { animation-duration: 300ms; animation-timing-function: cubic-bezier(0.2, 0.0, 0, 1.0); }
</style>

<script>

  class Web4UI {
    #transport = new WebSocketTransport();
    keyholes = new Web4Keyholes(this.#transport);

    getElementByKey(key) {
      return this.keyholes[key]?.element;
    }

    ping(repeat) {
      repeat = repeat ?? 1;
      console.time("ping");
      this.#transport.ping().then(() => {
        console.timeEnd("ping");
        if (--repeat > 0)
          this.ping(repeat);
      });
    }

    setTitle(title) {
      document.title = title;
    }
  }

  class Web4Keyholes {
    #transport;

    constructor(transport) {
      this.#transport = transport;
    }

    set(key, node, booleanAttributeName) {
      this[key] = new Web4Keyhole(this.#transport, key, node);
      if (booleanAttributeName)
        this[key].booleanAttributeName = booleanAttributeName;
      else
        delete this.booleanAttributeName;
    }

    get elements() {
      return Object.fromEntries(Object
        .values(ui.keyholes)
        .map(k => [k.key, k.element]
      ));
    }

    dump() {
      this.#transport.dump();
    }
  }

  class Web4Keyhole {
    #transport;
    key;
    element;
    static #transitionBatch = {
      mutations: [],
      elements: [],
      duplicatesOld: {},
      duplicatesNew: {},
      keyholesInvalidated: false
    };

    static {
      document.addEventListener('DOMContentLoaded', () => document.registerKeyholes());
    }

    constructor(transport, key, element) {
      this.#transport = transport;
      this.key = key;
      this.element = element;
    }

    setTextNode(value) {
      this.element.nodeValue = value;
    }

    setAttribute(value) {
      if (this.booleanAttributeName) {
        this.element[this.booleanAttributeName] = value;
      } else {
        this.element.value = value;
      }
    }

    setElement(rawHtml, viewTransitionName, viewTransitionNameSecondary) {
      let oldElement = this.element;
      let newElement = document.createRange().createContextualFragment(rawHtml).children[0];
      newElement.registerKeyholes(this.key);
      [ viewTransitionName, viewTransitionNameSecondary ] = this.#fixDuplicates(viewTransitionName, viewTransitionNameSecondary);

      let mutation = () => oldElement.replaceWith(newElement);

      if (!this.element.shouldAnimate(viewTransitionName)) {
        mutation();
      } else {
        this.#batchMutation(mutation, true);
        this.#prepareElement(newElement, viewTransitionName);
        this.#prepareElement(oldElement, viewTransitionNameSecondary ?? viewTransitionName);
      }
    }

    addElement(key, rawHtml, viewTransitionName) {
      let priorElement = this.element;
      let newElement = document.createRange().createContextualFragment(rawHtml).children[0];
      newElement.registerKeyholes(key);

      let mutation = () => priorElement.after(newElement);

      if (!this.element.shouldAnimate(viewTransitionName)) {
        mutation();
      } else {
        this.#batchMutation(mutation, false);
        this.#prepareSiblings();
      }
    }

    removeElement(viewTransitionName) {
      let mutation = () => this.element.parentNode.removeChild(this.element);

      if (!this.element.shouldAnimate(viewTransitionName)) {
        mutation();
      } else {
        this.#batchMutation(mutation, true);
        this.#prepareSiblings();
      }
    }

    dispatchEvent(event) {
      this.#transport.dispatchEvent(event, this.key);
    }

    #batchMutation(mutation, invalidatesKeyholes) {
      Web4Keyhole.#transitionBatch.mutations.push(mutation);

      if (invalidatesKeyholes)
        Web4Keyhole.#transitionBatch.keyholesInvalidated = true;
    }

    #prepareElement(element, viewTransitionName) {
      if (!Web4Keyhole.#transitionBatch.elements.includes(element))
        Web4Keyhole.#transitionBatch.elements.push(element);

      element.style.viewTransitionName = viewTransitionName;
    }

    #prepareSiblings() {
      this.element.parentElement.childNodes.forEach((sibling, i) => {
        if (!Web4Keyhole.#transitionBatch.elements.includes(sibling))
          Web4Keyhole.#transitionBatch.elements.push(sibling);
        
        if (sibling.style && !sibling.style.viewTransitionName)
          sibling.style.viewTransitionName = `web4-${this.key}-sibling-${i}`;
      });
    }

    #fixDuplicates(nameNew, nameOld) {
      let nameNewDupes = Web4Keyhole.#transitionBatch.duplicatesNew[nameNew];
      if (!nameNewDupes) { nameNewDupes = 1; } else { nameNewDupes++; }
      Web4Keyhole.#transitionBatch.duplicatesNew[nameNew] = nameNewDupes;

      let nameOldDupes = Web4Keyhole.#transitionBatch.duplicatesOld[nameOld];
      if (!nameOldDupes) { nameOldDupes = 1; } else { nameOldDupes++; }
      Web4Keyhole.#transitionBatch.duplicatesOld[nameOld] = nameOldDupes;

      return [
        nameNewDupes <= 1 ? nameNew : `${nameNew}-${nameNewDupes}`,
        nameOldDupes <= 1 ? nameOld : `${nameOld}-${nameOldDupes}`
      ];
    }

    static flushTransitionBatch() {
      let mutations = Web4Keyhole.#transitionBatch.mutations;
      let elements = Web4Keyhole.#transitionBatch.elements;
      let keyholesInvalidated = Web4Keyhole.#transitionBatch.keyholesInvalidated;

      if (!document.startViewTransition || mutations.length == 0) {
        if (keyholesInvalidated)
          document.unregisterKeyholes();
        return;
      }

      Web4Keyhole.#transitionBatch.mutations = [];
      Web4Keyhole.#transitionBatch.elements = [];
      Web4Keyhole.#transitionBatch.duplicatesNew = {};
      Web4Keyhole.#transitionBatch.duplicatesOld = {};
      Web4Keyhole.#transitionBatch.keyholesInvalidated = false;

      document.startViewTransition(() => {
        mutations.forEach(mutation => mutation());
      })
      .finished.then(() => {
        elements.forEach(element => {
          if (element.style?.viewTransitionName?.startsWith("web4")) {
            element.style.removeProperty("view-transition-name");
            if (element.style.length == 0)
              element.removeAttribute("style");
          }
        });
        if (keyholesInvalidated)
          document.unregisterKeyholes();
      });
    }
  }

  class WebSocketTransport {
    #webSocket = new WebSocket(`${location.pathname === '/' ? '' : location.pathname}/web4`);
    #messageID = 0;
    #reconnectionAttempts = 0;
    #promises = new Map();

    constructor() {
      this.#webSocket.onmessage = e => this.#handleMessage(e);
      this.#webSocket.onerror = e => console.error(e);
      this.#webSocket.onopen = e => this.#updateConnectionState(this.#webSocket, e);
      this.#webSocket.onclose = e => this.#updateConnectionState(this.#webSocket, e);
      setTimeout(e => this.#updateConnectionState(this.#webSocket, e), 1000);
      window.addEventListener("online", e => this.#updateConnectionState(this.#webSocket, e));
      window.addEventListener("visibilitychange", e => this.#updateConnectionState(this.#webSocket, e));
      window.onbeforeunload = e => this.#webSocket = undefined;
    }

    dispatchEvent(event, key) {
      let params = [event, Event.prototype.NEXT_PROPAGATION_ID];
      if (Event.prototype.NEXT_PROPAGATION_LEVEL)
        params.push(Event.prototype.NEXT_PROPAGATION_LEVEL)

      let message = {
        jsonrpc: "2.0", 
        method: `ui.keyholes.${key}.dispatchEvent`, 
        params: params
      };
      this.#webSocket.send(JSON.stringify(message));
    }
    
    ping() {
      let message = { 
        jsonrpc: "2.0", 
        method: "ui.ping", 
        id: ++this.#messageID,
      };
      this.#webSocket.send(JSON.stringify(message));

      return new Promise((resolve, reject) => {
        this.#promises.set(this.#messageID, { resolve, reject });
      });
    }

    dump() {
      let message = {
        jsonrpc: "2.0", 
        method: "ui.keyholes.dump", 
      };
      this.#webSocket.send(JSON.stringify(message));
    }

    #handleMessage(event) {
      let batch = JSON.parse(event.data);
      batch = Array.isArray(batch) ? batch : [batch];
      batch.forEach(rpc => {

        // A function to call
        if (rpc.method) {
          let [obj, func] = rpc.method
            .split(".")
            .reduce(([obj, func], prop) => [func, func[prop]], [null, window]);
          func.apply(obj, rpc.params);
        }

        // A result to return
        if (rpc.id) {
          let promise = this.#promises.get(rpc.id);
          this.#promises.delete(rpc.id);
          if (rpc.error)
            promise.reject(rpc.error);
          else
            promise.resolve(rpc.result);
        }
      });

      Web4Keyhole.flushTransitionBatch();
    }

    async #updateConnectionState(e) {
      switch (this.#webSocket?.readyState) {
        case WebSocket.CONNECTING:
          this.#getOrCreateModal().showModal();
          break;
        case WebSocket.OPEN:
          document.getElementById("web4Modal")?.close();
          break;
        case WebSocket.CLOSING:
        case WebSocket.CLOSED:
          this.#getOrCreateModal().showModal();
          document.getElementById("web4ModalMessage").textContent = e.reason ? e.reason : "Looking for server...";
          if (this.#reconnectionAttempts == 0) {
            while (++this.#reconnectionAttempts <= 10) {
              console.debug(`Web4 reconnect: (attempt ${this.#reconnectionAttempts} of 10)...`);
              new WebSocket(`${location.pathname}/web4/alive`)
                .onopen = e => location.reload();
              await new Promise(resolve => setTimeout(resolve, 1000));
            }
            this.#reconnectionAttempts = 0;
          }
          break;
      }
    }
    
    #getOrCreateModal() {
      let web4Modal = document.getElementById("web4Modal");
      if (!web4Modal) {
        document.body.appendChild(web4ModalTemplate.content.cloneNode(true));
        web4Modal = document.getElementById("web4Modal")
      }
      return web4Modal;
    }
  }

  this.ui = new Web4UI();

  Event.prototype.trim = function(members) {
    const ALLOWED_EVENT_PROPERTIES = [ "absolute", "acceleration", "accelerationIncludingGravity", "alpha", "altitudeAngle", "altKey", "animationName", "azimuthAngle", "beta", "bubbles", "button", "buttons", "cancelable", "changedTouches", "clientX", "clientY", "code", "colNo", "composed", "ctrlKey", "currentTarget", "data", "dataTransfer", "defaultPrevented", "deltaMode", "deltaX", "deltaY", "deltaZ", "detail", "elapsedTime", "error", "eventPhase", "fileName", "gamma", "height", "inputType", "interval", "isComposing", "isPrimary", "isTrusted", "key", "length", "lengthComputable", "lineNo", "loaded", "location", "message", "metaKey", "movementX", "movementY", "newState", "newUrl", "offsetX", "offsetY", "oldState", "oldUrl", "pageX", "pageY", "persisted", "pointerID", "pointerType", "pressure", "propertyName", "pseudoElement", "relatedTarget", "repeat", "rotationRate", "screenX", "screenY", "shiftKey", "skipped", "submitter", "tangentialPressure", "target", "targetTouches", "timeStamp", "tiltX", "tiltY", "total", "touches", "twist", "type", "width", "x", "y", "id", "name", "value", "checked" ];

    if (!this.propagationID) {
      this.propagationID = ++Event.prototype.NEXT_PROPAGATION_ID;
      this.currentTarget.propagationID = this.propagationID;
      Event.prototype.NEXT_PROPAGATION_LEVEL = 0;
    }

    if (this.currentTarget.propagationID != this.propagationID) {
      this.currentTarget.propagationID = this.propagationID;
      Event.prototype.NEXT_PROPAGATION_LEVEL++;
    }

    if (!members)
      return {};
    
    if (typeof members === "string")
      members = members.split(",");

    if (members.includes("preventDefault"))
      this.preventDefault();

    if (members.includes("*"))
      members = ALLOWED_EVENT_PROPERTIES;

    let trimmed = {};
    
    members.forEach(member => {
      member = member.trim();
      if (member in this) {
        if (this[member] instanceof EventTarget) {
          let eventTarget = {};
          if (this[member].id) eventTarget.id = this[member].id;
          if (this[member].name) eventTarget.name = this[member].name;
          if (this[member].value) eventTarget.value = this[member].value;
          if (this[member].value === "on") eventTarget.checked = this[member].checked;
          if (Object.keys(eventTarget).length > 0)
            trimmed[member] = eventTarget;
        } else {
          trimmed[member] = this[member];
        }
      }
    });

    return trimmed;
  }
  
  Event.prototype.NEXT_PROPAGATION_ID = 0;
  Event.prototype.NEXT_PROPAGATION_LEVEL = 0;

  HTMLElement.prototype.shouldAnimate = function(viewTransitionName) {
    // TODO: Not sure about BODY tag.  Perhaps better to verify by CSS props instead?
    let isInAnimationContainer =  ["ROW", "COL", "LIST", "BODY"].includes(this.parentElement.tagName);
    return document.startViewTransition && viewTransitionName && isInAnimationContainer;
  }

  Node.prototype.registerKeyholes = function(key) {
    if (key)
      ui.keyholes.set(key, this);

    let comments = document.evaluate('//comment()', this, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
    for (let i = comments.snapshotLength - 1; i >= 0; i--) {
      let comment = comments.snapshotItem(i);
      let key = comment.textContent;
      if (key.startsWith('key')) {
        let element = comment.previousSibling;
        if (element.nodeType === Node.COMMENT_NODE) {
          // Text node was missing because keyhole value was "", e.g. `<!----><!--key123-->`
          element = element.parentNode.insertBefore(document.createTextNode(""), comment);
        }
        ui.keyholes.set(key, element);
      }
      comment.parentElement.removeChild(comment);
    }
    
    let attrs = document.evaluate('//*/attribute::*', this, null, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
    for (let i = 0; i < attrs.snapshotLength; i++) {
      let attr = attrs.snapshotItem(i);
      let key = attr.name;
      if (key.startsWith('key')) {
        if (attr.value === "") {
          let element = attrs.snapshotItem(i - 1)
          ui.keyholes.set(key, element);
        } else {
          ui.keyholes.set(key, attr.ownerElement, attr.value);
        }
        attr.ownerElement.removeAttribute(attr.name)
      }
    }
  }

  HTMLDocument.prototype.unregisterKeyholes = function() {
    for (let key in ui.keyholes) {
      let element = ui.keyholes[key].element;
      if (element.nodeType == Node.ATTRIBUTE_NODE)
        element = element.ownerElement;
      if (element instanceof Node && element != document && !document.body.contains(element))
        delete ui.keyholes[key];
    }
  }

</script>

<template id="web4ModalTemplate">
  <dialog id="web4Modal" onkeydown="event.preventDefault()">
    <div>
      <progress></progress>
      <div id="web4ModalMessage">Looking for server...</div>
    </div>
  </dialog>
  <style>
    #web4Modal::backdrop { background-color: #ffffff66; backdrop-filter: grayscale(0.75) blur(6px); }
    #web4Modal:focus { outline: none; }
    #web4Modal[open] { 
      background-color: transparent; 
      border-width: 0;
      animation: .5s cubic-bezier(0.165, 0.840, 0.440, 1.000) forwards zoom-fade-in;
    }
  </style>
</template>
