<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />

<style>
    body {
        font-family: sans-serif;
        height: 100vh;
        margin: 0;
        touch-action: pan-x pan-y;
        display: flex; flex-direction: column; justify-content: center;
    }
    column { display: flex; flex-direction: column; justify-content: center; }
    row    { display: flex; flex-direction: row;    justify-content: center; }

    @keyframes slide-in        { from { opacity: 0; translate: 50px; } }
    @keyframes slide-out       { to   { opacity: 0; translate: -50px; } }
    @keyframes zoom-fade-in    { from { opacity: 0; scale: 1.2; } }
    @keyframes zoom-fade-out   { to   { opacity: 0; scale: .8; } }
    ::view-transition-group(*) { animation-duration: 300ms; animation-timing-function: ease-in-out; }
</style>

<script>

  function clientRpc(event) {
    let batch = JSON.parse(event.data);
    batch = Array.isArray(batch) ? batch : [batch];
    batch.forEach(rpc => {
      let func = rpc.method
        .split(".")
        .reduce((obj, prop) => obj[prop], window);
      func(...rpc.params);
    });
  }

  class Web4Rpc {
    client = new Web4RpcClient();
    server = new Web4RpcServer();
    keyholes = {};
  }

  class Web4RpcClient {
    constructor() {
      document.addEventListener('DOMContentLoaded', () => {
        Web4RpcClient.#registerKeyholes(document);
      });
    }

    setTextNode(key, value) {
      let textNode = rpc.keyholes[key];
      textNode.nodeValue = value;
    }

    setAttribute(key, value) {
      let attribute = rpc.keyholes[key];
      if (typeof value !== "boolean") {
        attribute.value = value;
      } else {
        let attrName = attribute.booleanAttribute;
        attribute.owner[attrName] = value;
      }
    }

    setElement(key, rawHtml, transition) {
      let oldElement = rpc.keyholes[key];
      let newElement = document
        .createRange()
        .createContextualFragment(rawHtml)
        .children[0];
      rpc.keyholes[key] = newElement;
      Web4RpcClient.#registerKeyholes(newElement);

      // No transition
      let isInTransitionContainer = ["ROW", "COL", "BODY"].includes(oldElement.parentElement.tagName);
      if (!document.startViewTransition || !transition || !isInTransitionContainer) {
        oldElement.replaceWith(newElement);
        return;
      }
      
      // View Transition API
      let direction = !rawHtml.includes("World") ? "fwd" : "rev"; // TODO: FAKE!!!
      let viewTransitionName = `web4-${key}-${direction}`;
      oldElement.style.viewTransitionName = viewTransitionName;
      newElement.style.viewTransitionName = viewTransitionName;
      oldElement.parentElement.childNodes.forEach((sibling, i) => {
        if (sibling != oldElement && sibling.style)
          sibling.style.viewTransitionName = `web4-sibling-${i}`
      });

      document.startViewTransition(() => {
        oldElement.replaceWith(newElement);
      })
      .finished.then(() => {
        newElement.parentElement.childNodes.forEach(sibling => {
          if (sibling.style?.viewTransitionName?.startsWith("web4")) {
            sibling.style.removeProperty("view-transition-name");
            if (sibling.style.length == 0)
              sibling.removeAttribute("style");
          }
        });
      });
    }

    addElement() {
    }

    removeElement() {
    }

    moveElement() {
    }

    static #registerKeyholes(parentNode) {
      let comments = document.evaluate('//comment()', parentNode, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
      for (let i = comments.snapshotLength - 1; i >= 0; i--) {
        let comment = comments.snapshotItem(i);
        let key = comment.textContent;
        if (key.startsWith('key')) {
          let keyhole = comment.previousSibling;
          if (keyhole.nodeType === Node.COMMENT_NODE) {
            // Text node was missing because keyhole value was "", e.g. `<!----><!--key123-->`
            keyhole = keyhole.parentNode.insertBefore(document.createTextNode(""), comment);
          }
          rpc.keyholes[key] = keyhole;
        }
        comment.parentElement.removeChild(comment);
      }
      
      let attrs = document.evaluate('//*/attribute::*', parentNode, null, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
      for (let i = 0; i < attrs.snapshotLength; i++) {
        let attr = attrs.snapshotItem(i);
        let key = attr.name;
        if (key.startsWith('key')) {
          if (attr.value === "") {
            rpc.keyholes[key] = attrs.snapshotItem(i - 1);
          } else {
            rpc.keyholes[key] = { 
              nodeType: Node.ENTITY_REFERENCE_NODE, 
              booleanAttribute: attr.value, 
              owner: attr.ownerElement
            };
          }
          attr.ownerElement.removeAttribute(attr.name)
        }
      }
    }
  }

  class Web4RpcServer {
    #webSocket;

    console = new Web4RpcConsole();

    constructor() {
      document.addEventListener('DOMContentLoaded', () => {
        this.connect();
      });
    }

    connect() {      
      this.#webSocket?.close();
      this.#webSocket = new WebSocket(`${location.pathname}/web4`);
      this.#webSocket.onmessage = clientRpc;
      this.#webSocket.onerror = console.error;
      this.#webSocket.onopen = e => this.#updateConnectionState(e);
      this.#webSocket.onclose = e => this.#updateConnectionState(e);
      setTimeout(e => this.#updateConnectionState(e), 1000);
      window.addEventListener("online", e => this.#updateConnectionState(e));
      window.addEventListener("visibilitychange", e => this.#updateConnectionState(e));
      window.onbeforeunload = e => this.#webSocket = undefined;
    }

    dispatchEvent(key, event, includeProperties) {
      if (event && !event.propagationID)
        event.propagationID = ++propagationID;

      if (includeProperties?.includes("preventDefault")) {
        event?.preventDefault();
        if (includeProperties === "preventDefault")
          includeProperties = null;
      }
      includeProperties = includeProperties?.split(",") ?? ALLOWED_EVENT_PROPERTIES;

      let message = JSON.stringify(
        { jsonrpc: "2.0", method: key, params: event }, 
        [ "jsonrpc", "method", "params", ...includeProperties, "propagationID" ]
      );
      this.#webSocket.send(message);
    }
    
    async #updateConnectionState(e) {
      switch (this.#webSocket?.readyState) {
        case WebSocket.CONNECTING:
          this.#getOrCreateModal().showModal();
          break;
        case WebSocket.OPEN:
          document.getElementById("web4Modal")?.close();
          break;
        case WebSocket.CLOSING:
        case WebSocket.CLOSED:
          this.#getOrCreateModal().showModal();
          document.getElementById("web4ModalMessage").textContent = e.reason ? e.reason : "Looking for server...";
          if (reconnectionAttempts == 0) {
            while (++reconnectionAttempts <= 10) {
              console.debug(`Web4 reconnect: (attempt ${reconnectionAttempts} of 10)...`);
              new WebSocket(`${location.pathname}/web4/alive`)
                .onopen = e => location.reload();
              await new Promise(resolve => setTimeout(resolve, 1000));
            }
            reconnectionAttempts = 0;
          }
          break;
      }
    }

    #getOrCreateModal() {
      let web4Modal = document.getElementById("web4Modal");
      if (!web4Modal) {
        document.body.appendChild(web4ModalTemplate.content.cloneNode(true));
        web4Modal = document.getElementById("web4Modal")
      }
      return web4Modal;
    }
  }

  class Web4RpcConsole {
    connect() {
      new EventSource(`${location.pathname}/web4/console`)
        .onmessage = clientRpc;
    }

    disconnect() {
    }
  }

  window.rpc = new Web4Rpc();

  let propagationID = 0;
  let reconnectionAttempts = 0;
  const ALLOWED_EVENT_PROPERTIES = [ "absolute", "acceleration", "accelerationIncludingGravity", "alpha", "altitudeAngle", "altKey", "animationName", "azimuthAngle", "beta", "bubbles", "button", "buttons", "cancelable", "changedTouches", "clientX", "clientY", "code", "colNo", "composed", "ctrlKey", "currentTarget", "data", "dataTransfer", "defaultPrevented", "deltaMode", "deltaX", "deltaY", "deltaZ", "detail", "elapsedTime", "error", "eventPhase", "fileName", "gamma", "height", "inputType", "interval", "isComposing", "isPrimary", "isTrusted", "key", "length", "lengthComputable", "lineNo", "loaded", "location", "message", "metaKey", "movementX", "movementY", "newState", "newUrl", "offsetX", "offsetY", "oldState", "oldUrl", "pageX", "pageY", "persisted", "pointerID", "pointerType", "pressure", "propertyName", "pseudoElement", "relatedTarget", "repeat", "rotationRate", "screenX", "screenY", "shiftKey", "skipped", "submitter", "tangentialPressure", "target", "targetTouches", "timeStamp", "tiltX", "tiltY", "total", "touches", "twist", "type", "width", "x", "y", "id", "name", "value", "checked" ];

</script>

<template id="web4ModalTemplate">
  <dialog id="web4Modal" onkeydown="event.preventDefault()">
    <div>
      <progress></progress>
      <div id="web4ModalMessage">Looking for server...</div>
    </div>
  </dialog>
  <style>
    #web4Modal::backdrop { background-color: #ffffff66; backdrop-filter: grayscale(0.75) blur(6px); }
    #web4Modal:focus { outline: none; }
    #web4Modal[open] { 
        background-color: transparent; 
        border-width: 0;
        animation: .5s cubic-bezier(0.165, 0.840, 0.440, 1.000) forwards zoom-fade-in;
    }
  </style>
</template>
