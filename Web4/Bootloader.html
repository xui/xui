
<!-- <link rel="manifest" href="/app/manifest.json" /> -->
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />

<style>
    body {
        font-family: sans-serif;
        height: 100vh;
        margin: 0;
        touch-action: pan-x pan-y;
        display: flex; flex-direction: column; justify-content: center;
    }
    column { display: flex; flex-direction: column; justify-content: center; }
    row    { display: flex; flex-direction: row;    justify-content: center; }
    list   { display: flex; flex-direction: column; justify-content: center; }
    lr     { display: flex; flex-direction: row;    justify-content: center; }
    ld     { display: flex; flex-direction: column; justify-content: center; }
    svg    { margin: 8px; }

    @keyframes slide-in        { from { opacity: 0; translate: 50px; } }
    @keyframes slide-out       { to   { opacity: 0; translate: -50px; } }
    @keyframes zoom-fade-in    { from { opacity: 0; scale: 1.2; } }
    @keyframes zoom-fade-out   { to   { opacity: 0; scale: .8; } }
    ::view-transition-group(*) { animation-duration: 300ms; animation-timing-function: ease-in-out; }
</style>

<script>

  class Web4App {
    #transport = new WebSocketTransport();
    keyholes = new Web4Keyholes(this.#transport);

    getElementByKey(key) {
      return this.all[key].element;
    }

    dispatchEvent(event, key) {
      this.#transport.dispatchEvent(event, key);
    }

    ping(repeat) {
      repeat = repeat ?? 1;
      console.time("ping");
      this.#transport.ping().then(() => {
        console.timeEnd("ping");
        if (--repeat > 0)
          this.ping(repeat);
      });
    }

    // Proxied from window.document
    setTitle = title => document.title = title;
  }

  class Web4Keyholes {
    #transport;
    all = {};

    constructor(transport) {
      this.#transport = transport;
      // Object.defineProperty(this, 'all', { get() { return this.#all; } });
      document.addEventListener('DOMContentLoaded', () => this.#registerKeyholes(document));
    }

    get elements() {
      let e = {};
      for (let key in this.all) {
        e[key] = this.all[key].element;
      }
      return e;
    }

    dump() {
      this.#transport.dump();
    }

    setTextNode = function(key, value) {
      let textNode = this.all[key].element;
      textNode.nodeValue = value;
    }

    setAttribute = function(key, value) {
      let keyhole = this.all[key];
      if (typeof value !== "boolean") {
        keyhole.value = value;
      } else {
        let attrName = keyhole.booleanAttribute;
        keyhole.element[attrName] = value;
      }
    }

    setElement = function(key, rawHtml, transition) {
      let oldElement = this.all[key].element;
      let newElement = document
        .createRange()
        .createContextualFragment(rawHtml)
        .children[0];
      let parentElement = oldElement.parentElement;
      this.all[key] = { element: newElement };
      this.#registerKeyholes(newElement);

      // No transition
      let isInTransitionContainer = ["ROW", "COL", "LIST", "BODY"].includes(parentElement.tagName);
      if (!document.startViewTransition || !transition || !isInTransitionContainer) {
        oldElement.replaceWith(newElement);
        return;
      }
      
      // View Transition API
      let direction = !rawHtml.includes("World") ? "fwd" : "rev"; // TODO: FAKE!!!
      parentElement.childNodes.forEach((sibling, i) => {
        if (sibling.style)
          sibling.style.viewTransitionName = `web4-sibling-${i}`
      });
      oldElement.style.viewTransitionName = `web4-${key}-${direction}`;
      newElement.style.viewTransitionName = `web4-${key}-${direction}`;

      document.startViewTransition(() => {
        oldElement.replaceWith(newElement);
      })
      .finished.then(() => {
        parentElement.childNodes.forEach(sibling => {
          if (sibling.style?.viewTransitionName?.startsWith("web4")) {
            sibling.style.removeProperty("view-transition-name");
            if (sibling.style.length == 0)
              sibling.removeAttribute("style");
          }
        });

        this.#unregisterKeyholes();
      });
    }

    addElement = function(key, priorKey, rawHtml, transition) {
      let priorElement = this.all[priorKey].element;
      let newElement = document
        .createRange()
        .createContextualFragment(rawHtml)
        .children[0];
      let parentElement = priorElement.parentElement;
      this.all[key] = { element: newElement };
      this.#registerKeyholes(newElement);

      // No transition
      let isInTransitionContainer = ["ROW", "COL", "LIST", "BODY"].includes(parentElement.tagName);
      if (!document.startViewTransition || !transition || !isInTransitionContainer) {
        priorElement.after(newElement);
        return;
      }
      
      // View Transition API
      let direction = !rawHtml.includes("World") ? "fwd" : "rev"; // TODO: FAKE!!!
      parentElement.childNodes.forEach((sibling, i) => {
        if (sibling.style)
          sibling.style.viewTransitionName = `web4-sibling-${i}`
      });

      document.startViewTransition(() => {
        priorElement.after(newElement);
      })
      .finished.then(() => {
        parentElement.childNodes.forEach(sibling => {
          if (sibling.style?.viewTransitionName?.startsWith("web4")) {
            sibling.style.removeProperty("view-transition-name");
            if (sibling.style.length == 0)
              sibling.removeAttribute("style");
          }
        });
      });
    }

    removeElement = function(key, transition) {
      let element = this.all[key].element;

      // No transition
      let isInTransitionContainer = ["ROW", "COL", "LIST", "BODY"].includes(element.parentElement.tagName);
      if (!document.startViewTransition || !transition || !isInTransitionContainer) {
        element.parentNode.removeChild(element);
        return;
      }

      // View Transition API
      let parentElement = element.parentElement;
      parentElement.childNodes.forEach((sibling, i) => {
        if (sibling.style)
          sibling.style.viewTransitionName = `web4-sibling-${i}`
      });
      element.style.viewTransitionName = `web4-${key}`;

      document.startViewTransition(() => {
        element.parentNode.removeChild(element);
      })
      .finished.then(() => {
        parentElement.childNodes.forEach(sibling => {
          if (sibling.style?.viewTransitionName?.startsWith("web4")) {
            sibling.style.removeProperty("view-transition-name");
            if (sibling.style.length == 0)
              sibling.removeAttribute("style");
          }
        });

        this.#unregisterKeyholes();
      });
    }

    #registerKeyholes(parentNode) {
      let comments = document.evaluate('//comment()', parentNode, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
      for (let i = comments.snapshotLength - 1; i >= 0; i--) {
        let comment = comments.snapshotItem(i);
        let key = comment.textContent;
        if (key.startsWith('key')) {
          let element = comment.previousSibling;
          if (element.nodeType === Node.COMMENT_NODE) {
            // Text node was missing because keyhole value was "", e.g. `<!----><!--key123-->`
            element = element.parentNode.insertBefore(document.createTextNode(""), comment);
          }
          this.all[key] = { element };
        }
        comment.parentElement.removeChild(comment);
      }
      
      let attrs = document.evaluate('//*/attribute::*', parentNode, null, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
      for (let i = 0; i < attrs.snapshotLength; i++) {
        let attr = attrs.snapshotItem(i);
        let key = attr.name;
        if (key.startsWith('key')) {
          if (attr.value === "") {
            this.all[key] = { element: attrs.snapshotItem(i - 1) };
          } else {
            this.all[key] = { 
              nodeType: Node.ENTITY_REFERENCE_NODE, 
              booleanAttribute: attr.value, 
              element: attr.ownerElement
            };
          }
          attr.ownerElement.removeAttribute(attr.name)
        }
      }

      this.#unregisterKeyholes();
    }

    #unregisterKeyholes() {
      // for (let key in this.all) {
      //   let element = this.all[key].element;
      //   if (!(element instanceof Node))
      //     element = element.owner;
      //   if (!document.body.contains(element))
      //     delete this.all[key];
      // }
    }
  }

  class WebSocketTransport {
    #webSocket = new WebSocket(`${location.pathname}/web4`);
    #messageID = 0;
    #reconnectionAttempts = 0;
    #promises = new Map();

    constructor() {
      this.#webSocket.onmessage = e => this.#callAll(e);
      this.#webSocket.onerror = e => console.error(e);
      this.#webSocket.onopen = e => this.#updateConnectionState(this.#webSocket, e);
      this.#webSocket.onclose = e => this.#updateConnectionState(this.#webSocket, e);
      setTimeout(e => this.#updateConnectionState(this.#webSocket, e), 1000);
      window.addEventListener("online", e => this.#updateConnectionState(this.#webSocket, e));
      window.addEventListener("visibilitychange", e => this.#updateConnectionState(this.#webSocket, e));
      window.onbeforeunload = e => this.#webSocket = undefined;
    }

    dispatchEvent(event, key) {
      let message = {
        jsonrpc: "2.0", 
        method: "app.dispatchEvent", 
        params: [event, key, Event.prototype.NEXT_PROPAGATION_ID]
      };
      this.#webSocket.send(JSON.stringify(message));
    }
    
    ping() {
      let message = { 
        jsonrpc: "2.0", 
        method: "app.ping", 
        id: ++this.#messageID,
      };
      this.#webSocket.send(JSON.stringify(message));

      return new Promise((resolve, reject) => {
        this.#promises.set(this.#messageID, { resolve, reject });
      });
    }

    dump() {
      let message = {
        jsonrpc: "2.0", 
        method: "app.keyholes.dump", 
      };
      this.#webSocket.send(JSON.stringify(message));
    }

    #callAll(event) {
      let batch = JSON.parse(event.data);
      batch = Array.isArray(batch) ? batch : [batch];
      batch.forEach(rpc => {

        // A function to call
        if (rpc.method) {
          let [obj, func] = rpc.method
            .split(".")
            .reduce(([obj, func], prop) => [func, func[prop]], [null, window]);
          func.apply(obj, rpc.params);
        }

        // A result to return
        if (rpc.id) {
          let promise = this.#promises.get(rpc.id);
          if (rpc.error)
            promise.reject(rpc.error);
          else
            promise.resolve(rpc.result);
        }
      });
    }

    async #updateConnectionState(e) {
      switch (this.#webSocket?.readyState) {
        case WebSocket.CONNECTING:
          this.#getOrCreateModal().showModal();
          break;
        case WebSocket.OPEN:
          document.getElementById("web4Modal")?.close();
          break;
        case WebSocket.CLOSING:
        case WebSocket.CLOSED:
          this.#getOrCreateModal().showModal();
          document.getElementById("web4ModalMessage").textContent = e.reason ? e.reason : "Looking for server...";
          if (this.#reconnectionAttempts == 0) {
            while (++this.#reconnectionAttempts <= 10) {
              console.debug(`Web4 reconnect: (attempt ${this.#reconnectionAttempts} of 10)...`);
              new WebSocket(`${location.pathname}/web4/alive`)
                .onopen = e => location.reload();
              await new Promise(resolve => setTimeout(resolve, 1000));
            }
            this.#reconnectionAttempts = 0;
          }
          break;
      }
    }
    
    #getOrCreateModal() {
      let web4Modal = document.getElementById("web4Modal");
      if (!web4Modal) {
        document.body.appendChild(web4ModalTemplate.content.cloneNode(true));
        web4Modal = document.getElementById("web4Modal")
      }
      return web4Modal;
    }
  }

  this.app = new Web4App();

  Event.prototype.trim = function(members) {
    const ALLOWED_EVENT_PROPERTIES = [ "absolute", "acceleration", "accelerationIncludingGravity", "alpha", "altitudeAngle", "altKey", "animationName", "azimuthAngle", "beta", "bubbles", "button", "buttons", "cancelable", "changedTouches", "clientX", "clientY", "code", "colNo", "composed", "ctrlKey", "currentTarget", "data", "dataTransfer", "defaultPrevented", "deltaMode", "deltaX", "deltaY", "deltaZ", "detail", "elapsedTime", "error", "eventPhase", "fileName", "gamma", "height", "inputType", "interval", "isComposing", "isPrimary", "isTrusted", "key", "length", "lengthComputable", "lineNo", "loaded", "location", "message", "metaKey", "movementX", "movementY", "newState", "newUrl", "offsetX", "offsetY", "oldState", "oldUrl", "pageX", "pageY", "persisted", "pointerID", "pointerType", "pressure", "propertyName", "pseudoElement", "relatedTarget", "repeat", "rotationRate", "screenX", "screenY", "shiftKey", "skipped", "submitter", "tangentialPressure", "target", "targetTouches", "timeStamp", "tiltX", "tiltY", "total", "touches", "twist", "type", "width", "x", "y", "id", "name", "value", "checked" ];
    if (!this.propagationID)
      this.propagationID = ++Event.prototype.NEXT_PROPAGATION_ID;

    if (!members)
      return {};
    
    if (typeof members === "string")
      members = members.split(",");

    if (members.includes("preventDefault"))
      this.preventDefault();

    if (members.includes("*"))
      members = ALLOWED_EVENT_PROPERTIES;

    let trimmed = {};
    
    members.forEach(member => {
      member = member.trim();
      if (member in this) {
        if (this[member] instanceof EventTarget) {
          let eventTarget = {};
          if (this[member].id) eventTarget.id = this[member].id;
          if (this[member].name) eventTarget.name = this[member].name;
          if (this[member].value) eventTarget.value = this[member].value;
          if (this[member].value === "on") eventTarget.checked = this[member].checked;
          if (Object.keys(eventTarget).length > 0)
            trimmed[member] = eventTarget;
        } else {
          trimmed[member] = this[member];
        }
      }
    });

    return trimmed;
  }
  
  Event.prototype.NEXT_PROPAGATION_ID = 0;

</script>

<template id="web4ModalTemplate">
  <dialog id="web4Modal" onkeydown="event.preventDefault()">
    <div>
      <progress></progress>
      <div id="web4ModalMessage">Looking for server...</div>
    </div>
  </dialog>
  <style>
    #web4Modal::backdrop { background-color: #ffffff66; backdrop-filter: grayscale(0.75) blur(6px); }
    #web4Modal:focus { outline: none; }
    #web4Modal[open] { 
        background-color: transparent; 
        border-width: 0;
        animation: .5s cubic-bezier(0.165, 0.840, 0.440, 1.000) forwards zoom-fade-in;
    }
  </style>
</template>
