
<!-- <link rel="manifest" href="/app/manifest.json" /> -->
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />

<style>
    body {
        font-family: sans-serif;
        height: 100vh;
        margin: 0;
        touch-action: pan-x pan-y;
        display: flex; flex-direction: column; justify-content: center;
    }
    column { display: flex; flex-direction: column; justify-content: center; }
    row    { display: flex; flex-direction: row;    justify-content: center; }
    list   { display: flex; flex-direction: column; justify-content: center; }
    lr     { display: flex; flex-direction: row;    justify-content: center; }
    ld     { display: flex; flex-direction: column; justify-content: center; }
    svg    { margin: 8px; }

    @keyframes slide-in        { from { opacity: 0; translate: 50px; } }
    @keyframes slide-out       { to   { opacity: 0; translate: -50px; } }
    @keyframes zoom-fade-in    { from { opacity: 0; scale: 1.2; } }
    @keyframes zoom-fade-out   { to   { opacity: 0; scale: .8; } }
    ::view-transition-group(*) { animation-duration: 300ms; animation-timing-function: ease-in-out; }
</style>

<script>

  class Web4App {
    #transport = new WebSocketTransport();
    keyholes = new Web4Keyholes(this.#transport);

    getElementByKey(key) {
      return this.keyholes[key]?.element;
    }

    dispatchEvent(event, key) {
      this.#transport.dispatchEvent(event, key);
    }

    ping(repeat) {
      repeat = repeat ?? 1;
      console.time("ping");
      this.#transport.ping().then(() => {
        console.timeEnd("ping");
        if (--repeat > 0)
          this.ping(repeat);
      });
    }

    setTitle(title) {
      document.title = title;
    }
  }

  class Web4Keyholes {
    #transport;

    constructor(transport) {
      this.#transport = transport;
    }

    get elements() {
      return Object.fromEntries(Object
        .values(app.keyholes)
        .filter(k => k.key.startsWith("key"))
        .map(k => [k.key, k.element]
      ));
    }

    dump() {
      this.#transport.dump();
    }
  }

  class Web4Keyhole {
    key;
    element;

    static {
      document.addEventListener('DOMContentLoaded', () => Web4Keyhole.#registerKeyholes());
    }

    constructor(key, element) {
      this.key = key;
      this.element = element;
    }
    
    setTextNode(value) {
      this.element.nodeValue = value;
    }

    setAttribute(value) {
      if (this.booleanAttributeName) {
        this.element[this.booleanAttributeName] = value;
      } else {
        this.element.value = value;
      }
    }

    setElement(rawHtml, transition) {
      let oldElement = this.element;
      let newElement = document.createRange().createContextualFragment(rawHtml).children[0];
      Web4Keyhole.#registerKeyholes(newElement, this.key);

      if (this.#shoudUseTransition(transition)) {
          let direction = !rawHtml.includes("World") ? "fwd" : "rev"; // TODO: FAKE!!!
          oldElement.style.viewTransitionName = `web4-${this.key}-${direction}`;
          newElement.style.viewTransitionName = `web4-${this.key}-${direction}`;
      }

      this.#mutate(
        transition,
        () => oldElement.replaceWith(newElement),
        () => Web4Keyhole.#unregisterKeyholes()
      )
    }

    addElement(key, rawHtml, transition) {
      let priorElement = this.element;
      let newElement = document.createRange().createContextualFragment(rawHtml).children[0];
      Web4Keyhole.#registerKeyholes(newElement, key);

      this.#mutate(
        transition,
        () => priorElement.after(newElement)
      )
    }

    removeElement(transition) {
      if (this.#shoudUseTransition(transition)) {
        this.element.style.viewTransitionName = `web4-${this.key}`;
      }

      this.#mutate(
        transition,
        () => this.element.parentNode.removeChild(this.element),
        () => Web4Keyhole.#unregisterKeyholes()
      )
    }

    #mutate(transition, mutate, finish) {
      // No transition
      if (!this.#shoudUseTransition(transition)) {
        mutate();
        if (finish) finish();
        return;
      }

      // View Transition API
      let parentElement = this.element.parentElement;
      parentElement.childNodes.forEach((sibling, i) => {
        if (sibling.style && !sibling.style.viewTransitionName)
          sibling.style.viewTransitionName = `web4-sibling-${i}`
      });
      document.startViewTransition(() => {
        mutate();
      })
      .finished.then(() => {
        parentElement.childNodes.forEach(sibling => {
          if (sibling.style?.viewTransitionName?.startsWith("web4")) {
            sibling.style.removeProperty("view-transition-name");
            if (sibling.style.length == 0)
              sibling.removeAttribute("style");
          }
        });
        if (finish) finish();
      });
    }

    #shoudUseTransition(transition) {
      let doesParentSupportTransition = ["ROW", "COL", "LIST", "BODY"].includes(this.element.parentElement.tagName);
      return transition && document.startViewTransition && doesParentSupportTransition;
    }

    static #registerKeyholes(node, key) {
      if (node) {
        app.keyholes[key] = new Web4Keyhole(key, node);
      } else {
        node = document;
      }
      let comments = document.evaluate('//comment()', node, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
      for (let i = comments.snapshotLength - 1; i >= 0; i--) {
        let comment = comments.snapshotItem(i);
        let key = comment.textContent;
        if (key.startsWith('key')) {
          let element = comment.previousSibling;
          if (element.nodeType === Node.COMMENT_NODE) {
            // Text node was missing because keyhole value was "", e.g. `<!----><!--key123-->`
            element = element.parentNode.insertBefore(document.createTextNode(""), comment);
          }
          app.keyholes[key] = new Web4Keyhole(key, element);
        }
        comment.parentElement.removeChild(comment);
      }
      
      let attrs = document.evaluate('//*/attribute::*', node, null, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
      for (let i = 0; i < attrs.snapshotLength; i++) {
        let attr = attrs.snapshotItem(i);
        let key = attr.name;
        if (key.startsWith('key')) {
          if (attr.value === "") {
            let element = attrs.snapshotItem(i - 1)
            app.keyholes[key] = new Web4Keyhole(key, element);
          } else {
            app.keyholes[key] = new Web4Keyhole(key, attr.ownerElement);
            app.keyholes[key].booleanAttributeName = attr.value;
          }
          attr.ownerElement.removeAttribute(attr.name)
        }
      }
    }

    static #unregisterKeyholes() {
      for (let key in app.keyholes) {
        let element = app.keyholes[key].element;
        if (element.nodeType == Node.ATTRIBUTE_NODE)
          element = element.ownerElement;
        if (!document.body.contains(element))
          delete app.keyholes[key];
      }
    }
  }

  class WebSocketTransport {
    #webSocket = new WebSocket(`${location.pathname}/web4`);
    #messageID = 0;
    #reconnectionAttempts = 0;
    #promises = new Map();

    constructor() {
      this.#webSocket.onmessage = e => this.#callAll(e);
      this.#webSocket.onerror = e => console.error(e);
      this.#webSocket.onopen = e => this.#updateConnectionState(this.#webSocket, e);
      this.#webSocket.onclose = e => this.#updateConnectionState(this.#webSocket, e);
      setTimeout(e => this.#updateConnectionState(this.#webSocket, e), 1000);
      window.addEventListener("online", e => this.#updateConnectionState(this.#webSocket, e));
      window.addEventListener("visibilitychange", e => this.#updateConnectionState(this.#webSocket, e));
      window.onbeforeunload = e => this.#webSocket = undefined;
    }

    dispatchEvent(event, key) {
      let message = {
        jsonrpc: "2.0", 
        method: "app.dispatchEvent", 
        params: [event, key, Event.prototype.NEXT_PROPAGATION_ID]
      };
      this.#webSocket.send(JSON.stringify(message));
    }
    
    ping() {
      let message = { 
        jsonrpc: "2.0", 
        method: "app.ping", 
        id: ++this.#messageID,
      };
      this.#webSocket.send(JSON.stringify(message));

      return new Promise((resolve, reject) => {
        this.#promises.set(this.#messageID, { resolve, reject });
      });
    }

    dump() {
      let message = {
        jsonrpc: "2.0", 
        method: "app.keyholes.dump", 
      };
      this.#webSocket.send(JSON.stringify(message));
    }

    #callAll(event) {
      let batch = JSON.parse(event.data);
      batch = Array.isArray(batch) ? batch : [batch];
      batch.forEach(rpc => {

        // A function to call
        if (rpc.method) {
          let [obj, func] = rpc.method
            .split(".")
            .reduce(([obj, func], prop) => [func, func[prop]], [null, window]);
          func.apply(obj, rpc.params);
        }

        // A result to return
        if (rpc.id) {
          let promise = this.#promises.get(rpc.id);
          this.#promises.delete(rpc.id);
          if (rpc.error)
            promise.reject(rpc.error);
          else
            promise.resolve(rpc.result);
        }
      });
    }

    async #updateConnectionState(e) {
      switch (this.#webSocket?.readyState) {
        case WebSocket.CONNECTING:
          this.#getOrCreateModal().showModal();
          break;
        case WebSocket.OPEN:
          document.getElementById("web4Modal")?.close();
          break;
        case WebSocket.CLOSING:
        case WebSocket.CLOSED:
          this.#getOrCreateModal().showModal();
          document.getElementById("web4ModalMessage").textContent = e.reason ? e.reason : "Looking for server...";
          if (this.#reconnectionAttempts == 0) {
            while (++this.#reconnectionAttempts <= 10) {
              console.debug(`Web4 reconnect: (attempt ${this.#reconnectionAttempts} of 10)...`);
              new WebSocket(`${location.pathname}/web4/alive`)
                .onopen = e => location.reload();
              await new Promise(resolve => setTimeout(resolve, 1000));
            }
            this.#reconnectionAttempts = 0;
          }
          break;
      }
    }
    
    #getOrCreateModal() {
      let web4Modal = document.getElementById("web4Modal");
      if (!web4Modal) {
        document.body.appendChild(web4ModalTemplate.content.cloneNode(true));
        web4Modal = document.getElementById("web4Modal")
      }
      return web4Modal;
    }
  }

  this.app = new Web4App();

  Event.prototype.trim = function(members) {
    const ALLOWED_EVENT_PROPERTIES = [ "absolute", "acceleration", "accelerationIncludingGravity", "alpha", "altitudeAngle", "altKey", "animationName", "azimuthAngle", "beta", "bubbles", "button", "buttons", "cancelable", "changedTouches", "clientX", "clientY", "code", "colNo", "composed", "ctrlKey", "currentTarget", "data", "dataTransfer", "defaultPrevented", "deltaMode", "deltaX", "deltaY", "deltaZ", "detail", "elapsedTime", "error", "eventPhase", "fileName", "gamma", "height", "inputType", "interval", "isComposing", "isPrimary", "isTrusted", "key", "length", "lengthComputable", "lineNo", "loaded", "location", "message", "metaKey", "movementX", "movementY", "newState", "newUrl", "offsetX", "offsetY", "oldState", "oldUrl", "pageX", "pageY", "persisted", "pointerID", "pointerType", "pressure", "propertyName", "pseudoElement", "relatedTarget", "repeat", "rotationRate", "screenX", "screenY", "shiftKey", "skipped", "submitter", "tangentialPressure", "target", "targetTouches", "timeStamp", "tiltX", "tiltY", "total", "touches", "twist", "type", "width", "x", "y", "id", "name", "value", "checked" ];
    if (!this.propagationID)
      this.propagationID = ++Event.prototype.NEXT_PROPAGATION_ID;

    if (!members)
      return {};
    
    if (typeof members === "string")
      members = members.split(",");

    if (members.includes("preventDefault"))
      this.preventDefault();

    if (members.includes("*"))
      members = ALLOWED_EVENT_PROPERTIES;

    let trimmed = {};
    
    members.forEach(member => {
      member = member.trim();
      if (member in this) {
        if (this[member] instanceof EventTarget) {
          let eventTarget = {};
          if (this[member].id) eventTarget.id = this[member].id;
          if (this[member].name) eventTarget.name = this[member].name;
          if (this[member].value) eventTarget.value = this[member].value;
          if (this[member].value === "on") eventTarget.checked = this[member].checked;
          if (Object.keys(eventTarget).length > 0)
            trimmed[member] = eventTarget;
        } else {
          trimmed[member] = this[member];
        }
      }
    });

    return trimmed;
  }
  
  Event.prototype.NEXT_PROPAGATION_ID = 0;

</script>

<template id="web4ModalTemplate">
  <dialog id="web4Modal" onkeydown="event.preventDefault()">
    <div>
      <progress></progress>
      <div id="web4ModalMessage">Looking for server...</div>
    </div>
  </dialog>
  <style>
    #web4Modal::backdrop { background-color: #ffffff66; backdrop-filter: grayscale(0.75) blur(6px); }
    #web4Modal:focus { outline: none; }
    #web4Modal[open] { 
        background-color: transparent; 
        border-width: 0;
        animation: .5s cubic-bezier(0.165, 0.840, 0.440, 1.000) forwards zoom-fade-in;
    }
  </style>
</template>
